openapi: 3.0.0
info:
    
  version: '1.0-alpha'

  title: EGC API

  ## Note that description fields may use Common Markdown 
  ## (supported by OpenApi 3)
 
  description: | 
    # EGC API
    
    ## Design considerations
    
    ### Two-phase send
    
    Sending a new MSI is two-phase (create then send). This is
    because the msiId value is a critical piece of information
    for the client (to be able to check status and/or cancel)
    and the API design must ensure that the client is safely 
    in possession of msiID before a send happens. If the 
    method was one phase then there would be no guarantee that
    the msiID was received (a failure could happen in any link
    in the return snetworking chain like a router, firewall, proxy 
    server or indeed a problem at the client application end
    that prevented persistence of the msiID for later use).
    Moreover, if the method was one phase and a failure in the
    network chain occurred then not only would an orphan MSI 
    be sent by the provider but the client would not have
    knowledge that the MSI had been successfully queued for
    sending and would naturally retry the send (multiple times
    even) and we end up with the same MSI being sent 2+ times.
    
    To further clarify the problem being solved by a two phase
    send here is a [discussion](https://stackoverflow.com/questions/49444723/how-to-make-sure-the-http-response-was-delivered) 
    of the delivery guarantees of HTTP responses. 
    
    Note that a one phase call where the client generated a new 
    unique id (using a UUID for instance) is a possible solution 
    but is less desirable because it introduces a problematic 
    edge case where the client accidentally uses the same id more
    than once. To detect this synchronously (to throw an immediate
    error) has scalability/availability consequences for the 
    server side because a transactional resource must be used
    (like a relational database) that can ensure single use of any 
    msiId. If the server creates the msiId and communicates it to
    the client then the server side can potentially be scaled with
    ease if the msiID is a UUID for instance (which is effectively 
    unique without coordination with other nodes).
    
    Note also that to support two-phase send an additional status
    value has been added, `CREATED`.
    
    ### Pagination
    
    The List MSIs action uses a paginated response as the number of 
    MSIs in a response can get large. Pagination can reduce server
    overhead and improve response times. Client-driven pagination is 
    where the client specifies an offset (skip) field and that number
    of rows is skipped by the server to return the next page. This
    can be inefficient for the server-side (see [discussion](
    https://use-the-index-luke.com/no-offset)) and it is preferred to 
    use server-driven pagination which is where each page returned 
    also includes a continuation token to be included in the next page 
    call. The nice thing about this approach is that the server side
    can simply return an offset in the continuation token if desired but 
    we enable more efficient techniques if wanted later.
    
    ### Client specific identifiers
    
    Early versions of this API have suggested the inclusion of a 
    `NationalSASId` field in the created MSI with the purpose of allowing 
    a client to correlate an MSI with its internal data. 
    
    This field is a convenience only and thus theoretically should not be
    included. A client should manage its correlations itself by storing the
    unique msiId returned by the service paired with its internal identifiers. 
    
    If something is required then it should be labelled something 
    like `tag` and have arbitrary values so that the client can use it for 
    anything. Labelling it `NationalSASId` suggests more meaning to the
    field than it may have. **TODO** confirm.
    
    ### Piracy broadcasts
    
    Piracy broadcasts appear to be structurally identical to Nav Warning
    broadcasts and so are modelled as Nav Warning broadcasts. **TODO** is there
    value in knowing that a Nav Warning broadcast was a piracy related
    broadcast? If so the we should add a `isPiracyWarning` boolean field to 
    the NavBroadcast (it is currently present).
    
    ### Geometry
    
    Note that the api below allows for float precision locations for 
    geographic circles and rectangles. An implementation of this API 
    may choose to use the location with reduced precision (for example
    lat longs rounded to nearest integer).
    
    ### Cancellation
    
    A PUT to an `/msi/[id}` path ]with content like `{"isCancelled":true}` 
    has been suggested as a way of cancelling a broadcast. This can be 
    achieved in a much simpler way with the DELETE verb without content 
    (a cancel action can be considered as a logical delete in the context
    of this API). A cancelled broadcast cannot be changed in status but 
    can be queried. 
    
    ### Abstraction of C-Codes
    Initial proposals for the API suggested a partial abstraction of C-Codes. 
    In particular Priority, MsiType and AreaType were abstracted. This API 
    demonstrates a full abstraction of C-Codes. It is equivalent to C-Codes
    but has an easier to read and process representation and the mapping to C-Codes 
    then becomes a server-side implementation detail. By using the data modelling
    constructs of OpenAPI v3 and JSON Schema users can generate code for their 
    API-consuming application that imposes compile-time checking (varies on language)
    instead of experiencing runtime failures.
    
    **TODO** is there a requirement for full explicit C-Code support (zero 
    abstraction)?
    
    ### Authentication
    Initial proposals for this API included a re-authenticate 
    method whereby a new token was returned if a currently valid token was 
    supplied. This is a security hole in that anyone in possession of one 
    valid token (but not the username and password) can stay authenticated 
    forever. In the same vein, a sensible limit on validity duration of a 
    token should be imposed. Common practice for token refresh in REST 
    services is to force a refresh every 15 minutes to an hour.
    
    Note that in the context of web applications the fact that the token
    refresh is at 15 minutes does not preclude the web application being 
    coded to only require username and password entry by a user every 
    N hours. It's just some additional coding that needs to happen to cache
    the username and password locally for a period. 
    
    ### Naming
    Previous API drafts used the field names `startDate` and `endDate` for an MSI.
    Given that those fields refer to timestamps not just dates the names `startTime`
    and `endTime` have been used.
    
    ### Additional Fields
    There are obvious use cases for the following additional fields on an MSI:
    
    * createTime
    * cancelledTime
    
    TODO confirm
    
paths:

  /authenticate:

    ###############################################
    ## Authenticate
    ###############################################   
    post:
      summary: Authenticate
      description: |
        Obtains a token that will be passed in a request header to calls
        to other paths on this API for authentication and authorization
        purposes.
      requestBody:
        description: | 
          username and password
        required: true
        content:
          application/json: 
            schema:
              $ref: '#/components/schemas/AuthenticationRequestBody'
      responses:
        '200':    
          description: token and expiry time
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/AuthenticationResponse' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '500':    
          $ref: '#/components/responses/ServerError'              
  
  /msi:
  
    ###############################################
    ## Create an MSI
    ###############################################      
    post:
      summary: Create MSI
      description: |
        Submits message content and returns a unique id (across all 
        users) that is to be used in the send method. It is ok for
        a message to never be sent but the provider should have the 
        freedom to clean up (delete) unsent messages after some 
        reasonable period or after more than N unsent messages are created.
        (**TODO** ask providers what is reasonable minimum period and 
        maximum number of unsent messages so it can be documented here). 
      requestBody:
        description: |
          Describes the message content.
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MsiContent'
      responses:
        '200':    
          description: The unique identifier of the newly created MSI
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/MsiId' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'
          
    ###############################################
    ## List MSIs
    ###############################################      
    get:
      summary: List MSIs
      description: |
        Returns Maritime Safety Information broadcasts requested to
        be sent by the user. 
        
        Note that none of the parameters are required and also that 
        just one of startTime or endTime can be 
        provided if desired.
        
        The limit field may not be honoured exactly by the server
        side (in that it might exceed a maximum limit of the server).
        
        The results of this query may return in any order and that order
        may vary in repeated calls (for example, the returned MSIs may 
        not be ordered by timestamp). If the client requires an ordering
        by time then all pages should be requested and then sorted 
        client-side. TODO confirm this
      parameters:
        - in: query
          name: startTime
          description: |
            If provided then only MSIs whose broadcasts for which 
            the msi.startTime satisfies the given criteria (either an 
            exact time or within a given possibly open ended range) are 
            included in the returned list of MSIs.
          schema:
            $ref: '#/components/schemas/ExactTimeOrRange' 
        - in: query
          name: endTime
          description: |
            If provided then only MSIs whose broadcasts for which 
            the msi.endTime satisfies the given criteria (either an 
            exact time or within a given possibly open ended range) are 
            included in the returned list of MSIs.
          schema:
            $ref: '#/components/schemas/ExactTimeOrRange'            
        - in: query
          name: limit
          description: |
            Requests that at most `limit` MSIs are returned in the call.
            The server may cap the requested `limit` (fewer items may be
            returned). To request the next page available include the 
            returned `continuationToken` in the next call. If there are 
            no more items available then the response will not contain
            a `continuationToken`.
          schema:
            type: integer
            minimum: 1
            default: 10
        - in: query
          name: status
          description: |
            Only MSIs that have a status in the given list
            are returned. If the list is empty (or the parameter
            is not present) then no filtering on status occurs.
            TODO support multi-status filtering or just one?
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Status'
        - in: query
          name: msiType
          schema:
            $ref: '#/components/schemas/MsiType' 
          description: TODO
        - in: query
          name: continuationToken
          schema:
            $ref: '#/components/schemas/ContinuationToken' 
          description: |
            Describes to the server the starting point of 
            the next page of results and is obtained from 
            the current page. May contain an offset if desired
            but is at the discretion of implementer.
        ## review other fields, acks etc.
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                type: object
                properties:
                  msis:
                    type: array
                    items: 
                      $ref: '#/components/schemas/Msi'
                  continuationToken:
                    $ref: '#/components/schemas/ContinuationToken'
                required: [msis]
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'
          
  /msi/{id}:
    parameters:
      - $ref: '#/components/parameters/MsiId'
    
    ###############################################
    ## Get an MSI
    ############################################### 
    get:
      summary: Get MSI
      description: |
        Returns the details of an MSI broadcast using the unique MSI identifier.
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/Msi'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'
        '500':    
          $ref: '#/components/responses/ServerError'

    ###############################################
    ## Send an MSI
    ###############################################      
    put:
      summary: Send MSI
      description: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent or the MSI has been cancelled then 
        nothing occurs (this method is idempotent). 
      responses:
        '200':    
          description: OK
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'              

    ###############################################
    ## Cancel an MSI
    ############################################### 
    delete:
      summary: Cancel MSI 
      description: |
        This is a logical delete of a broadcast in that it
        prevents future broadcasts happening for this msiId
        (be it a single or repeating broadcast). Once cancelled
        an MSI cannot be resent. However, the broadcast details 
        are still available to be queried.
      responses:
        '204':    
          description: OK (No Content)
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'       
                                   
components:
  parameters:
    MsiId:
      in: path
      name: id
      schema:
        $ref: '#/components/schemas/MsiId'
      description: unique msi identifier
      required: true
        
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
            
    Unauthorized:
      description: Unauthorized (must authenticate)
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
            
    Forbidden:
      description: Not allowed
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                                    
    ServerError:
      description: Unexpected error on the server
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                      
  schemas:
    Error:
      description: an error message (response)
      type: object
      properties:
        ## all properties optional
        errorMessage: 
          type: string
        errorType:
          type: string
        stackTrace:
          type: array
          items: 
            type: string
        cause:
          $ref: '#/components/schemas/Error' 

    AuthenticationRequestBody:
      description: |
        Holds the credentials and validity preference used to 
        create a token to be passed as a request header in calls
        to the API
      type: object
      properties:
        username:
          type: string
          minLength: 1
        password:
          type: string
          minLength: 1
        validityMinutes:
          description: | 
            The duration in minutes that the token will be valid, 
            capped by the maximum allowed server-decided duration.  
            If not supplied (this parameter is optional) then the
            server default will be applied. Either way the response
            from this method supplies the expiry time for the
            token. The token should be refreshed before the expiry 
            time to avoid auth related failures.
          type: integer
          minimum: 1
      required: [username, password]
          
    AuthenticationResponse:
      type: object
      properties:
        token: 
          type: string
          minLength: 1
        expiryTime:
          type: string
          format: datetime
          description: |
            An expiryTime should always accompany the token
            because a requested validity duration may be 
            capped by the server and the client needs to know 
            what the resultant expiry time was.
      required: [token, expiryTime]
        
    MsiId:
      type: string
      minLength: 1
      maxLength: 255
      example: 289ee192-fdf5-4070-befc-3bf7291c1386
      
    SARPriority:
      type: string
      enum: [SAFETY, URGENCY, DISTRESS]
      example: SAFETY
    
    NonSARPriority:
      type: string
      enum: [SAFETY, URGENCY]
      example: URGENCY
      
    Status:
      type: string
      enum: [CREATED, SCHEDULED, ACTIVE, FINISHED, CANCELLED]
      example: ACTIVE
      
    MsiType:
      type: string
      enum: [SARBroadcast, MetBroadcast, NavBroadcast]
      example: SARBroadcast
      
    Payload:
      description: the ASCII message text to broadcast
      type: string
      minLength: 1
      maxLength: 65535 ## TODO what max length is appropriate?
      example: |
        a message to be broadcast 
      
    Latitude:
      type: number
      format: float
      minimum: -90
      maximum: 90
      
    Longitude:
      type: number
      format: float
      minimum: -180
      maximum: 180
      
    ExactTimeOrRange:
      oneOf:
      - $ref: '#/components/schemas/Time'
      - $ref: '#/components/schemas/TimeRange'
      example:
        min: '2022-04-23T18:25:43.511Z'
        max: '2022-04-27T20:00:00.000Z'
        maxInclusive: false

    Time:
      type: string
      format: datetime
      example: '2022-04-23T18:25:43.511Z'
      
    TimeRange:
      type: object
      properties:
        min:
          type: string
          format: datetime
        max:
          type: string
          format: datetime
        minInclusive:
          type: boolean
          description: |
            if not present then assumed true
        maxInclusive:
          type: boolean
          description: |
            if not present then assumed true
      description: |
        A time range with optional min or max. If neither are
        present then represents all time.
      
    Circle:
      type: object
      properties:
        lat:
          $ref: '#/components/schemas/Latitude' 
        lon:
          $ref: '#/components/schemas/Longitude' 
        radiusNm:
          type: number
          format: float
      required: [lat, lon, radiusNm]
      
    Rectangle:
      type: object
      properties: 
        minLat: 
          $ref: '#/components/schemas/Latitude'
        leftLon: 
          $ref: '#/components/schemas/Longitude' 
        heightDegrees:
          type: number
          format: float
          minimum: 0
          exclusiveMinimum: true
          maximum: 180
        widthDegrees:
          type: number
          format: float
          minimum: 0
          exclusiveMinimum: true
          maximum: 360
      required: [minLat, leftLon, heightDegrees, widthDegrees]
                
    Geometry:
      oneOf:
      - $ref: '#/components/schemas/Rectangle'
      - $ref: '#/components/schemas/Circle'
      discriminator:
        propertyName: geometryType
      example:
        geometryType: Circle
        lat: -42.5
        lon: 135.884
        radiusNm: 100.5
        
    MsiContent:
      type: object
      description: |
        Used to create a new MSI. `repetition` is optional. If omitted
        once only is assumed (no repetition). `startTime` and
        `endTime` are optional fields and 0, 1 or both can be
        present.
      properties:
        broadcast:
          oneOf:
          - $ref: '#/components/schemas/SARBroadcast'
          - $ref: '#/components/schemas/MetBroadcast'
          - $ref: '#/components/schemas/NavBroadcast'
          discriminator:
            propertyName: msiType
        startTime:
          type: string
          format: datetime
          description: the scheduled time of the initial broadcast
        endTime:
          type: string
          format: datetime
          description: |
            the time after which no more broadcasts should be made
            of this MSI 
        payload: 
          $ref: '#/components/schemas/Payload'          
        repetition:
          $ref: '#/components/schemas/Repetition' 
      ## repetition is optional
      required: [broadcast, payload]
        
    Msi:
      type: object
      description: |
        Represents a created MMSI (with an identifier).
        
        `repetition` is optional. If omitted once only is assumed
        (no repetition). `startTime` and `endTime`
        are optional fields and 0, 1 or both can be present.
      properties:
        id: 
          $ref: '#/components/schemas/MsiId'
        broadcast:
          oneOf:
          - $ref: '#/components/schemas/SARBroadcast'
          - $ref: '#/components/schemas/MetBroadcast'
          - $ref: '#/components/schemas/NavBroadcast'
          discriminator:
            propertyName: broadcastType
          example:
            broadcastType: SARBroadcast
            geometry: 
              geometryType: Circle
              lat: -34.5
              lon: 145.44
              radiusNm: 150
            priority: SAFETY
        createTime:
          type: string
          format: datetime
          description: |
            when the MSI was created
          example: '2022-04-23T10:25:43.511Z'
        cancelledTime:
          type: string
          format: datetime
          description: |
            when the MSI was cancelled. This field should be set
            if the status is CANCELLED.
          example: '2022-04-24T13:28:43.511Z'
        startTime:
          type: string
          format: datetime
          description: |
            Start time of the broadcast schedule
          example: '2022-04-23T10:30:43.511Z'
        endTime:
          type: string
          format: datetime
          description: |
            End time of the broadcast schedule
          example: '2022-04-24T10:25:43.511Z'
        payload: 
          $ref: '#/components/schemas/Payload'
        status:
          $ref: '#/components/schemas/Status'   
        repetition:
          $ref: '#/components/schemas/Repetition'
      ## repetition is optional
      required: [id, broadcast, createTime, startTime, endTime, status]
        
    SARBroadcast:
      type: object
      description: |
        area is optional. If omitted then corresponds to the
        entire coverage area.
      properties: 
        geometry:
          $ref: '#/components/schemas/SARBroadcastArea'
        priority:
          $ref: '#/components/schemas/SARPriority'
      required: [priority]
          
    SARBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/NavArea'
      discriminator:
        propertyName: sarBroadcastAreaType
         
    MetBroadcast:
      type: object
      properties:
        area:
          $ref: '#/components/schemas/MetBroadcastArea' 
        priority:
          $ref: '#/components/schemas/NonSARPriority'
      required: [area]
      
    MetBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/MetArea'
      - $ref: '#/components/schemas/CoastalWarningArea'
      discriminator:
        propertyName: metBroadcastAreaType
        
    NavBroadcast:
      type: object
      properties:
        area:
          $ref: '#/components/schemas/NavBroadcastArea' 
        priority:
          $ref: '#/components/schemas/NonSARPriority'
        isPiracyWarning:
          type: boolean
      required: [area, isPiracyWarning]        
        
    NavBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/NavArea'
      - $ref: '#/components/schemas/CoastalWarningArea'
      discriminator:
        propertyName: navBroadcastAreaType
              
    NavArea:
      properties: 
        navAreaCode:
          $ref: '#/components/schemas/NavAreaCode'
      required: [navAreaCode] 
          
    NavAreaCode:
      type: integer
      minimum: 1
      maximum: 21
          
    MetArea:
      properties: 
        metAreaCode:
          type: integer
          minimum: 1
          maximum: 21
      required: [metAreaCode]
          
    CoastalWarningArea:
      properties: 
        subjectIndicator:
          $ref: '#/components/schemas/SubjectIndicator'          
        navAreaCode:
          $ref: '#/components/schemas/NavAreaCode'
        coastalWarningAreaCode:
          type: string
          pattern: '[a-zA-Z]'
      required: [subjectIndicator, navAreaCode, coastalWarningAreaCode]
          
    SubjectIndicator:
      type: string
      enum: 
      - NAVIGATIONAL_WARNINGS
      - METEOROLOGICAL_WARNINGS
      - ICE_REPORTS
      - SAR_INFO_AND_PIRACY_WARNINGS
      - METEOROLOGICAL_FORECASTS
      - NOT_USED
      - SATNAV_MESSAGES
      - OTHER_ELECTRONIC_NAVAID_MESSAGES
      - OTHER_NAVIGATIONAL_WARNINGS
      - PILOT_SERVICE_MESSAGES
      - AIS
      - LORAN_MESSAGES
      - SPECIAL_SERVICES_V
      - SPECIAL_SERVICES_W
      - SPECIAL_SERVICES_X
      - SPECIAL_SERVICES_Y
      - NO_MESSAGES_ON_HAND
      description: |
        Subject indicator associated with a Coastal Warning
                    
    Repetition:
      type: object
      properties:
        repeatTillCancelled: 
          type: boolean
          description: |
            if false then one repetition is made (that
            is the broadcast happens twice)
        intervalHours: 
          type: integer
          enum: [1,2,3,4,5,6,12,18,24,30,36,48,60,72,96,120]  
          description: |
            the time gap between broadcasts of the same MSI   
      required: [repeatTillCancelled, intervalHours] 
      
    ContinuationToken:
      type: string
      minLength: 1
      maxLength: 4096
      description: |
        Indicates to the server the starting point of the next page 
        of results. The token is not expected to be anywhere near as
        long as 4096 characters but good to put an upper bound on it. 
      example: 10
