openapi: 3.0.0
info:
    
  version: '1.0-alpha'

  title: EGC API
  
  ## Note that Common Markdown is in theory supported for use in the OpenAPI 
  ## v3 description fields. As many YAML editors are not aware of this we 
  ## use the convention of not using # characters (headings in markdown) in
  ## multi-line descriptions and instead just use **bolding**.
  
  description: | 
    API for EGC provides to accept and manage broadcasts
    
    **Design considerations**
    
    *Two-phase send*
        
    Sending a new MSI is two-phase (create then send). This is
    because the msiId value is a critical piece of information
    for the client (to be able to check status and/or cancel)
    and the API design must ensure that the client is safely 
    in possession of msiID before a send happens. If the 
    method was one phase then there would be no guarantee that
    the msiID was received (a failure could happen in any link
    in the return snetworking chain like a router, firewall, proxy 
    server or indeed a problem at the client application end
    that prevented persistence of the msiID for later use).
    Moreover, if the method was one phase and a failure in the
    network chain occurred then not only would an orphan MSI 
    be sent by the provider but the client would not have
    knowledge that the MSI had been successfully queued for
    sending and would naturally retry the send (multiple times
    even) and we end up with the same MSI being sent 2+ times.
    
    To further clarify the problem being solved by a two phase
    send here is a discussion of the delivery guarantees of HTTP 
    responses, 
    https://stackoverflow.com/questions/49444723/how-to-make-sure-the-http-response-was-delivered.
    
    Note that a one phase call where the client generated a new 
    unique id (using a UUID for instance) is a possible solution 
    but is less desirable because it introduces a problematic 
    edge case where the client accidentally uses the same id more
    than once. To detect this synchronously (to throw an immediate
    error) has scalability/availability consequences for the 
    server side because a transactional resource must be used
    (like a relational database) that can ensure single use of any 
    msiId. If the server creates the msiId and communicates it to
    the client then the server side can potentially be scaled with
    ease if the msiID is a UUID for instance (which is effectively 
    unique without coordination with other nodes).
    
    Note also that to support two-phase send an additional status
    value has been added, `CREATED`.
    
    **Pagination**
    
    The List MSIs action uses a paginated response as the number of 
    MSIs in a response can get large. Client-driven pagination is 
    where the client specifies an offset (skip) field and that number
    of rows is skipped by the server to return the next page. This
    can be inefficient for the server-side (see 
    https://use-the-index-luke.com/no-offset) and it is preferred to 
    use server-driven pagination which is where each page returned 
    also includes a continuation token to be included in the next page 
    call. The nice thing about this approach is that the server side
    can simply return an offset in the continuation token if desired but 
    we enable more efficient techniques if wanted later.
    
    **Client specific identifiers**
    
    Early versions of this API have suggested the inclusion of a `National 
    SAS Id` field in the created MSI with the purpose of allowing a client
    to correlate an MSI with its internal data. 
    
    This field is a convenience only and thus should not be included. 
    A client should manage its correlations by storing the unique msiId 
    returned by the service paired with its internal identifiers. TODO
    confirm.
    
paths:
  
  /msi:
  
    ###############################################
    ## Create an MSI
    ###############################################      
    post:
      summary: |
        Submits message content and returns an id that is
        to be used in the send method. 
      description: |
        Submits message content and returns a unique id (across all 
        users) that is to be used in the send method. It is ok for
        a message to never be sent but the provider should have the 
        ability to clean up (delete) unsent messages after some 
        reasonable period (TODO ask providers what is reasonable
        minimum period so it can be documented here).
      requestBody:
        description: TODO
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MsiContent'
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                type: 
                  $ref: '#/components/schema/MsiId' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'
          
    ###############################################
    ## Send an MSI
    ###############################################      
    put:
      summary: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent then nothing occurs (this method is
        idempotent). 
      description: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent then nothing occurs (this method is
        idempotent). 
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '200':    
          description: OK
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'       

    ###############################################
    ## List MSIs
    ###############################################      
     get:
      summary: |
        Returns Maritime Safety Information broadcasts requested to
        be sent by the user. 
      description: |
        Note that none of the parameters are required and also that 
        just one of startTimeInclusive or endTimeExclusive can be 
        provided if desired.
        
        The limit field may not be honoured exactly by the server
        side (in that it might exceed a maximum limit of the server).
        
        The results of this query may return in any order and that order
        may vary in repeated calls (for example, the returned MSIs may 
        not be ordered by timestamp). If the client requires an ordering
        by time then all pages should be requested and then sorted 
        client-side. TODO confirm this
      parameters:
        - in: query
          name: startTimeInclusive
          description: TODO
          schema:
            type: datetime
        - in: query
          name: endTimeExclusive
          description: TODO
          schema:
            type: datetime
        - in: query
          name: limit
          description: TODO
          schema:
            type: integer
            minimum: 1
            default: 10
        - in: query
          name: status
          description: |
            Only MSIs that have a status in the given list
            are returned. If the list is empty (or the parameter
            is not present) then no filtering on status occurs.
            TODO support multi-status filtering or just one?
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Status'
        - in: query
          name: msiType
          schema:
            $ref:'#/components/schema/MsiType' 
          description: TODO
        - in: query
          name: continuationToken
          schema:
            $ref: '#/components/parameters/ContinuationToken' 
          description: |
            Describes to the server the starting point of 
            the next page of results and is obtained from 
            the current page. 
        ## review other fields 
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                type: object
                  properties:
                    msis:
                      type: array
                      items: 
                        $ref: '#/components/schemas/msi'
                    continuationToken:
                      
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'
          
  /msi/{id}:
  
    ###############################################
    ## Get an MSI
    ############################################### 
    get:
      summary: Returns Maritime Safety Information broadcasts requested to be sent by the user
      description: |
        TODO
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/msi'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'

    ###############################################
    ## Cancel an MSI
    ############################################### 
    delete:
      summary: Cancels an MSI broadcast 
      description: |
        This is a logical delete of a broadcast in that it
        prevents future broadcasts happening for this msiId
        (be it a single or repeating broadcast). Once cancelled
        an MSI cannot be resent. However, the broadcast details 
        are still available to be queried.
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '204':    
          description: OK (No Content)
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'       
                                   
components:
  parameters:
    MsiId:
      - in: path
        name: id
        schema:
          $ref: '#/components/schemas/MsiId'
        description: unique msi identifier
        required: true
        
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    ServerError:
      description: Unexpected error
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                      
  schemas:
    Error:
      type: object
      properties:
        errorMessage: 
          type: string
        errorType:
          type: string
        stackTrace:
          type: array
          items: 
            type: string
        cause:
          $ref: '#/components/schemas/Error'  
    Msi:
      type: object
      properties:
        id: 
          $ref: '#/components/schemas/MsiId'
          ## TODO add model
    MsiId:
      type: string
      minLength: 1
      maxLength: 255
    MsiType:
      type: string
      enum: [MSI, SAR, MET]
    AreaType: 
      type: string
      enum: [NAVMET, COASTAL, CIRCULAR, RECTANGULAR]
    Address:
      type: string
      ## TODO
    RepetitionCode:
      type: string
      ## TODO
    Priority:
      type: string
      enum: [SAFETY, URGENCY]
    ServiceCode:
      type: string
    Status:
      type: string
      enum: [CREATED, SCHEDULED, ACTIVE, FINISHED, CANCELLED]
    Payload:
      type: string
      minLength: 1
      maxLength: 65535 ## TODO what max length is appropriate?
      description: the IA5 message text to broadcast
    MsiContent:
      type: object
      properties:
        areaType:
          $ref: '#/components/schemas/AreaType'
        address:
          $ref: '#/components/schemas/Address'
        msiType: 
          $ref: '#/components/schemas/MsiType'
        startDate:
          type: datetime
          description: defaults to now if not present
        endDate:
          type: datetime
          description: defaults to now + 7 days if not present
        repetitionCode:
          $ref: '#/components/schemas/RepetitionCode'
        priority:
          $ref: '#/components/schemas/Priority'
        serviceCode:
          $ref: '#/components/schemas/ServiceCode'
        ## TODO acks?
        payload: 
          $ref: '#/components/schemas/Payload'
      required: [areaType, address, repetitionCode, priority, serviceCode, payload] 
    Msi:
      type: object
      properties:
        areaType:
          $ref: '#/components/schemas/AreaType'
        address:
          $ref: '#/components/schemas/Address'
        msiType: 
          $ref: '#/components/schemas/MsiType'
        startDate:
          type: datetime
        endDate:
          type: datetime
        repetitionCode:
          $ref: '#/components/schemas/RepetitionCode'
        priority:
          $ref: '#/components/schemas/Priority'
        serviceCode:
          $ref: '#/components/schemas/ServiceCode'
        ## TODO acks?
        payload: 
          $ref: '#/components/schemas/Payload'
        status:
          $ref: '#/components/schemas/Status' 
    ContinuationToken:
      type: string
      minLength: 1
      maxLength: 1024
