openapi: 3.0.0
info:
  version: '0.1'
  title: EGC
  description: API for EGC provides to accept broadcasts
    
## Note that Common Markdown is in theory supported for use in the OpenAPI 
## v3 description fields. As many YAML editors are not aware of this we 
## use the convention of not using # characters (headings in markdown) in
## multi-line descriptions and instead just use **bolding**.

paths:
  
  /msi:
  
    ###############################################
    ## Create an MSI
    ###############################################      
    post:
      summary: |
        Submits message content and returns an id that is
        to be used in the send method. 
      description: |
        Submits message content and returns a unique id (across all 
        users) that is to be used in the send method. It is ok for
        a message to never be sent but the provider should have the 
        ability to clean up (delete) unsent messages after some 
        reasonable period (TODO ask providers what is reasonable
        minimum period?).
      requestBody:
        description: TODO
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MsiContent'
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                type: 
                  $ref: '#/components/schema/MsiId' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'
          
    ###############################################
    ## Send an MSI
    ###############################################      
    put:
      summary: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent then nothing occurs (this method is
        idempotent). 
      description: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent then nothing occurs (this method is
        idempotent). 
        
        **Design considerations**
        
        Sending a new MSI is two-phase (create then send). This is
        because the msiId value is a critical piece of information
        for the client (to be able to check status and/or cancel)
        and the API design must ensure that the client is safely 
        in possession of msgId before a send happens. If the 
        method was one phase then there would be no guarantee that
        the msgId was received (a failure could happen in any link
        in the networking chain like a router, firewall, proxy 
        server or indeed a problem at the client application end
        that prevented persistence of the msgId for later use).
        Moreover, if the method was one phase and a failure in the
        network chain occurred then not only would an orphan MSI 
        be sent by the provider but the client would not have
        knowledge that the MSI had been successfully queued for
        sending and would naturally retry the send (multiple times
        even) and we end up with the same MSI being sent 2+ times.
        
        To further clarify the problem being solved by a two phase
        send here is a discussion of the delivery guarantees of HTTP 
        responses, https://stackoverflow.com/questions/49444723/how-to-make-sure-the-http-response-was-delivered
        
        Note that a one phase call where the client generated a new 
        unique id (using a UUID for instance) is a possible solution 
        but is less desirable because it introduces a problematic 
        edge case where the client accidentally uses the same id more
        than once. To detect this synchronously (to throw an immediate
        error) has scalability/availability consequences for the 
        server side because a transactional resource must be used
        (like a relational database) that can ensure single use of any 
        msiId. If the server creates the msgId and communicates it to
        the client then the server side can potentially be scaled with
        ease if the msgId is a UUID for instance (which is effectively 
        unique without coordination with other nodes). 
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '200':    
          description: OK
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'       

    ###############################################
    ## List MSIs
    ###############################################      
     get:
      summary: |
        Returns Maritime Safety Information broadcasts requested to
        be sent by the user. TODO should this include MSIs that have
        been created but not sent?
      description: |
        Note that none of the parameters are required and also that 
        just one of startTimeInclusive or endTimeExclusive can be 
        provided if desired.
      parameters:
        - in: query
          name: startTimeInclusive
          description: TODO
          schema:
            type: datetime
        - in: query
          name: endTimeExclusive
          description: TODO
          schema:
            type: datetime
        - in: query
          name: limit
          description: TODO
          schema:
            type: integer
            minimum: 1
            default: 10
        - in: query
          name: status
          description: |
            Only MSIs that have a status in the given list
            are returned. If the list is empty (or the parameter
            not present) then no filtering on status occurs.
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Status'
            
        ## Server-driven pagination is preferrable (continuationToken
        ## vs offset). Here's an RDB focused (but still relevant) 
        ## discussion of why it's better to use server-driven 
        ## pagination:
        ## https://use-the-index-luke.com/no-offset.
        ## The critical point to make is that if server-driven 
        ## pagination is used it's up to the server if it wants 
        ## to use offset style processing rather than index-based
        ## processing (or something else entirely).
        - in: query
          name: continuationToken
          schema:
            type: string
            minLength: 1
            maxLength: 1024
          description: TODO
        - in: query
          name: msiType
          schema:
            $ref:'#/components/schema/MsiType' 
          description: TODO
        - $ref: '#/components/parameters/msiType'
        - $ref: '#/components/parameters/status'
        ## review other fields 
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                type: array
                items: 
                  $ref: '#/components/schemas/msi'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'
          
  ## REST convention is for this query to use a path parameter
  /msi/{id}:
  
    ###############################################
    ## Get an MSI
    ############################################### 
    get:
      summary: Returns Maritime Safety Information broadcasts requested to be sent by the user
      description: |
        TODO
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/msi'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'

    ###############################################
    ## Cancel an MSI
    ############################################### 
    delete:
      summary: Cancels an MSI broadcast 
      description: |
        This is a logical delete of a broadcast in that it
        prevents future broadcasts happening for this msiId
        (be it a single or repeating broadcast). Once cancelled
        an MSI cannot be resent. However, the broadcast details 
        are still available to be queried.
      parameters:
        - $ref: '#/components/parameters/MsiId'
      responses:
        '204':    
          description: OK (No Content)
        '400':    
          $ref: '#/components/responses/BadRequest'
        '500':    
          $ref: '#/components/responses/ServerError'       
                                   
components:
  parameters:
    MsiId:
      - in: path
        name: id
        schema:
          $ref: '#/components/schemas/MsiId'
        description: unique msi identifier
        required: true
        
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    ServerError:
      description: Unexpected error
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                      
  schemas:
    Error:
      type: object
      properties:
        errorMessage: 
          type: string
        errorType:
          type: string
        stackTrace:
          type: array
          items: 
            type: string
        cause:
          $ref: '#/components/schemas/Error'  
    Msi:
      type: object
      properties:
        id: 
          $ref: '#/components/schemas/MsiId'
          ## TODO add model
    MsiId:
      type: string
      minLength: 1
      maxLength: 255
    MsiType:
      type: string
      enum: [MSI, SAR, MET]
    AreaType: 
      type: string
      enum: [NAVMET, COASTAL, CIRCULAR, RECTANGULAR]
    Address:
      type: string
      ## TODO
    RepetitionCode:
      type: string
      ## TODO
    Priority:
      type: string
      enum: [SAFETY, URGENCY]
    ServiceCode:
      type: string
      ## TODO
    ## TODO read acks, what are they!!!
    ## NationalSasID, not required
    Status:
      type: string
      enum: [CREATED, SENT]
    Payload:
      type: string
      minLength: 1
      maxLength: 65535 ## TODO
      description: C-codes at the moment. In the future this may be S-124 xml. 
    MsiContent:
      type: object
      properties:
        msiType: 
          $ref: '#/components/schemas/MsiType'
        payload: 
          $ref: '#/components/schemas/Payload'  
    Msi:
      type: object
      properties:
        msiType: 
          $ref: '#/components/schemas/MsiType'
        payload: 
          $ref: '#/components/schemas/Payload'
          
        
